ObjectView Objecten
====================

Vaak wil je de gegevens van een List object op een platte, gefilterde manier gebruiken. Om deze bijvoorbeeld in een tabel te tonen.
Omdat de Table en InteractiveTable een array verwacht kunnen de eigenschappen ook als array element worden gevraagd.

Het ObjectView object heeft 3 taken

1. Eigenschappen filteren, zodat je deze direct in een html-pagina kunt gebruiken. bijvoorbeeld:
  echo $CustomerView->lastname;   of    echo $CustomerView['lastname'];
Geeft hetzelde resultaat als:
  echo htmlentities($Customer->lastname);


2. Eigenschappen van de sub-objecten beschikbaar maken als directe eigenschap, bijvoorbeeld:
  echo $BookingView->hotel_name;
Geeft hetzelde resultaat als:
  echo htmlentities($Booking->Hotel->name);


3. Eigenschappen genereren, zodat je een waarde die uit een functie komt (get_prices()) gebruiken als eigenschap, daarnaast kun je html genereren. bijvoorbeeld:
  echo $BookingView->link;
i.p.v.
  echo '<a href="/booking/'.$Booking->id.'.html">'.$Booking->number.'</a>';
of:
  echo $StockItem->availability_type_icon;
Genereeerd dan bijvoorbeeld:
  <a src="/images/icons/availability/on_request.gif" title="Op aanvraag" />

Design keuzes
==============
Per List is er 1 instantie van een View object nodig. (i.p.v. voor elk BolObject ook een ViewObject) Hierdoor is er maar 1 List wrapper (ViewList) nodig voor alle objecten (i.p.v. een class per BolList object) en kun je het View object configureren voor de gehele lijst.

Veel functionalteit wordt in de (super)classes "AbstractView", "ArrayView", "ObjectView" en "BolObjectView" gestopt zodat je d.m.v.
configuratie het merendeel van de eigenschappen bepaald.
Het beschikbaar maken van de eigenschappen van sub-objecten wordt bijvoorbeeld in AbstractView gedaan.

protected functions i.p.v. een switch. Zodra je in een subclass van AbstractView een functie maakt die begint met 'get_$name' zal deze gebruikt worden om de eigenschap $name op te vragen.

De dynamische eigenschappen die vanuit het bron- object/array komen zijn "alleen lezen".

Focus op gebruik in de context van HTML. Alle eigenschappen wordt daarom standaard met htmlentities() gefiltert.


Gebruik / Voorbeelden
======================

Scenario 1: Een View gebruiken voor een enkel object
	$Booking = new Booking(123);
	$View = new BookingView; // Voor Booking en andere BOL objecten zijn al View classes gedefineerd
	$View->set_data($Booking);
	echo $View->label_icon; // Geeft het label van de booking als icoon.
"<img sr..."
Dit werkt als volgt: Alle eigenschappen die met "label_" beginnen worden via een ComplexType via de LabelView class opgrvraagd.
De LabelView wordt gevult met de $Booking->Label en het element "icon"
wordt opgevraagd. Omdat LabelView de functie get_icon() heeft wordt deze gebruikt om de HTML te genereren

Scenario 2: Een View gebruiken voor reeks objecten
	$BookingList = new BookingList(LANGUAGE_NL);
	$ViewList = new ViewList($BookingList, new BookingView);
	foreach ($ViewList as $row) {
		echo $row['hotel_city_name'];
		echo $row['customer_fullname'];
	}
In de foreach loop zal $row steeds hetzelde BookingView object zijn, maar met steeds een andere $Booking als inhoud.
De eigenschap "hotel_city_name" (die begint met "hotel_") wordt via een HotelView met de data uit $Booking->Hotel opgevraagd. Het HotelView krijgt dan de opdracht om "city_name" op te vragen.
Deze zal dan de "name" van $Booking->Hotel->Location object.

Scenario 3: Een tabel weergeven vanuit een List
	$List = new BookingList;
	$List->status = "SUCCESSFUL";
	$Command = new ListViewController($List, new BookingView);
	$Command->Table = new InteractiveTable(array(
		'label_icon',
		'number',
		'customer_fullname',
	), '/booking/', '.html');
	$Command->execute();
De ListViewController zal dan een tabel weergeven met de inhoud van de $List opgesplitst per 20 records.
De ListViewController zal via het View object de kolomnamen bepalen zodat er ipv "customer_fullname" "Customer" komt te staan.
Daarnaast zal hij de List kunnen sorteren dmv de "order_by" via de
View->convert_order_by($order_by) functie.


Opmerkingen
============
De BOL objecten kunnen zelf ook eigenschappen genereren.
Als het niet om HTML generatie gaat, bv: $nog_te_betalen zal de eigenschap in het bol object gegeneerd moeten worden.

Sorteren in SQL op een php gegenereerd veld zal een foutmelding geven.
Het instellen van de $ctViewList->order_by zal gefilterd moeten worden.



